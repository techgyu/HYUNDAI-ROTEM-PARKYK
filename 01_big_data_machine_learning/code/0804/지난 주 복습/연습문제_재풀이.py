# ----------------------------------step1_array 관련 문제.py------------------------------------
import numpy as np
print('-----------1) step1 : array 관련 문제-----------')
print('\nstep1: 정규분포를 따르는 난수를 이용하여 5행 4열 구조의 다차원 배열 객체를 생성하고, 각 행 단위로 합계, 최댓값을 구하시오.')

arr = np.random.randn(5, 4)

print('arr: \n', arr)
print('1행만 선택: \n', arr[0])
print('1행 합계: \n', np.sum(arr[0]))
print('1행 최댓값: \n', np.max(arr[0]))
print('2행 합계: \n',  np.sum(arr[1]))
print('2행 최댓값: \n',  np.max(arr[1]))
print('3행 합계: \n',  np.sum(arr[2]))
print('3행 최댓값: \n', np.max(arr[2]))


# ----------------------------------step2_indexing 관련 문제.py------------------------------------


print('-----------2) step2 : indexing 관련문제-----------')
print('\n 문2-1) 6행 6열의 다차원 zero 행렬 객체를 생성한 후 다음과 같이 indexing 하시오.')
#    조건1> 36개의 셀에 1~36까지 정수 채우기

#    조건2> 2번째 행 전체 원소 출력하기 

#               출력 결과 : [ 7.   8.   9.  10.  11.  12.]

#    조건3> 5번째 열 전체 원소 출력하기

#               출력결과 : [ 5. 11. 17. 23. 29. 35.]

#    조건4> 15~29 까지 아래 처럼 출력하기

#               출력결과 : 

#               [[15.  16.  17.]

#               [21.  22.  23]

#               [27.  28.  29.]]

arr = np.zeros((6, 6)) # 6행 6열의 다차원 zero 행렬 객체를 생성
print('6행 6열의 다차원 zero 행렬 객체를 생성: \n', arr)
arr.flat[:] = np.arange(1, 37) # 조건1> 36개의 셀에 1~36까지 정수 채우기
print('36개의 셀에 1~36까지 정수 채우기: \n', arr) 
print('2번째 행 전체 원소 출력하기', arr[1]) # 조건2> 2번째 행 전체 원소 출력하기
print('5번째 열 전체 원소 출력하기', arr[:, 4]) # 조건3> 5번째 열 전체 원소 출력하기
# 조건4> 15~29 까지 아래 처럼 출력하기
print('15~29 까지 아래 처럼 출력하기:\n', np.extract((arr >= 15) & (arr <= 29), arr).reshape(3, 5))

# --------------------------------------------------------------

print('문2-2) 6행 4열의 다차원 zero 행렬 객체를 생성한 후 아래와 같이 처리하시오.')
#조건1> 20~100 사이의 난수 정수를 6개 발생시켜 각 행의 시작열에 난수 정수를 저장하고, 
# 두 번째 열부터는 1씩 증가시켜 원소 저장하기
#조건2> 첫 번째 행에 1000, 마지막 행에 6000으로 요소값 수정하기

# <<출력 예시>>

# 1. zero 다차원 배열 객체
#   [[ 0.  0.  0.  0.]
#         ...
#    [ 0.  0.  0.  0.]]

# 2. 난수 정수 발생
# random.randint(s, e, n)

# 3. zero 다차원 배열에 난수 정수 초기화 결과. 두 번째 열부터는 1씩 증가시켜 원소 저장하기
# [[  90.   91.   92.   93.]
#  [  40.   41.   42.   43.]
#  [ 100.  101.  102.  103.]
#  [  22.   23.   24.   25.]
#  [  52.   53.   54.   55.]
#  [  71.   72.   73.   74.]]

# 4. 첫 번째 행에 1000, 마지막 행에 6000으로 수정
#  [[ 1000.  1000.  1000.  1000.]
#   [   40.    41.    42.    43.]
#   [  100.   101.   102.   103.]
#   [   22.    23.    24.    25.]
#   [   52.    53.    54.    55.]
#   [ 6000.  6000.  6000.  6000.]]

# 1. zero 다차원 배열 객체
arr = np.zeros((6, 4)) # zero 다차원 배열 객체
print('1. zero 다차원 배열 객체: \n', arr)

# #조건1> 20~100 사이의 난수 정수를 6개 발생시켜
# 각 행의 시작열에 난수 정수를 저장하고, 
# 두 번째 열부터는 1씩 증가시켜 원소 저장하기
print("2.1 20~100 사이의 난수 정수를 6개 발생:")
rand_six_num = np.random.randint(20, 100, 6)
print('rand_six_num:', rand_six_num)

print("2.2 각 행의 시작열에 난수 정수를 저장")
for i in range(6):
    arr[i][0] = rand_six_num[i]
print('arr: \n', arr)

print("2.3 두 번째 열부터는 1씩 증가시켜 원소 저장하기")
z = 1
for i in range(6):
    for t in range(1, 4):
        rand_six_num[i] += 1
        arr[i][t] = rand_six_num[i]
print('arr: \n', arr)

#조건2> 첫 번째 행에 1000, 마지막 행에 6000으로 요소값 수정하기
print("3,1 첫 번째 행에 1000")
for i in range(4):
    arr[0][i] = 1000
print('arr: \n', arr) 

print("3.2 마지막 행에 6000으로 요소값 수정하기")
for i in range(4):
    arr[5][i] = 6000
print('arr: \n', arr) 


# --------------------------------------step3_unifunc 관련 문제.py-------------------------------------------


import numpy as np
print('----------3) step3 : unifunc 관련문제-----------')
#   표준정규분포를 따르는 난수를 이용하여 4행 5열 구조의 다차원 배열을 생성한 후
#   아래와 같이 넘파이 내장함수(유니버설 함수)를 이용하여 기술통계량을 구하시오.
#   배열 요소의 누적합을 출력하시오.

# <<출력 예시>>
# ~ 4행 5열 다차원 배열 ~
# [[ 0.56886895  2.27871787 -0.20665035 -1.67593523 -0.54286047]
#            ...
#  [ 0.05807754  0.63466469 -0.90317403  0.11848534  1.26334224]]

# ~ 출력 결과 ~
# 평균 :
# 합계 :
# 표준편차 :
# 분산 :
# 최댓값 :
# 최솟값 :

# 1사분위 수 :           percentile()
# 2사분위 수 :
# 3사분위 수 :
# 요소값 누적합 :      cumsum()

print("1. 표준정규분포를 따르는 난수를 이용하여 4행 5열 구조의 다차원 배열을 생성")
np.random.seed(42) # 랜덤 시드 설정
arr = np.random.randn(4, 5)
print("arr:\n", arr)

print("2. 아래와 같이 넘파이 내장함수(유니버설 함수)를 이용하여 기술통계량을 구하시오.")
print("2.1 평균:")
print(np.mean(arr))

print("2.2 합계:")
print(np.sum(arr))

print("2.3 표준편차:")
print(np.std(arr))

print("2.4 분산:")
print(np.var(arr))

print("2.5 최댓값:")
print(np.max(arr))

print("2.6 최솟값:")
print(np.min(arr))

print("2.7 1사분위 수:")
print(np.percentile(arr, 25)) # 하위 4분의 1지점, 내부적으로 정렬(오른차순) 후 함수 실행

print("lowerdata: \n", (lowerdata := arr[arr <= np.percentile(arr, 25)]))

print("2.8 2사분위 수:")
print(np.percentile(arr, 50)) # 하위 4분의 2지점(중위수), 내부적으로 정렬(오른차순) 후 함수 실행

print("2.9 3사분위 수:")
print(np.percentile(arr, 75)) # 하위 4분의 3지점, 내부적으로 정렬(오른차순) 후 함수 실행

print("2.10 요소값 누적합 :")
print(np.cumsum(arr))

# ----------------------------------------보너스 문제.py-------------------------------------------
import numpy as np
print('----------numpy 문제 추가 ~~~~~~~~~~~~~~~~~~~~~-----------')

print('Q1) 브로드캐스팅과 조건 연산')
# 다음 두 배열이 있을 때,
# a = np.array([[1], [2], [3]])
# b = np.array([10, 20, 30])
# 두 배열을 브로드캐스팅하여 곱한 결과를 출력하시오.
# 그 결과에서 값이 30 이상인 요소만 골라 출력하시오.
print("1. 배열 생성")
a = np.array([[1], [2], [3]])
b = np.array([10, 20, 30])
print("2. 두 배열을 브로드캐스팅하여 곱한 결과를 출력하시오.")
print(a * b)

print("3. 그 결과에서 값이 30 이상인 요소만 골라 출력하시오.")
print((a * b)[(a * b) > 30])

# --------------------------------------------------------------

print('Q2) 다차원 배열 슬라이싱 및 재배열')
#  - 3×4 크기의 배열을 만들고 (reshape 사용),  
#  - 2번째 행 전체 출력
#  - 1번째 열 전체 출력
#  - 배열을 (4, 3) 형태로 reshape
#  - reshape한 배열을 flatten() 함수를 사용하여 1차원 배열로 만들기
print("1. 3×4 크기의 배열을 만들고 (reshape 사용)")
arr = np.random.randn(12).reshape(3, 4)
print("arr:\n", arr)

print("2. 2번째 행 전체 출력:\n", arr[1])

print("3. 1번째 열 전체 출력:\n", arr[:, 0])

print("4. 배열을 (4, 3) 형태로 reshape:\n", arr.reshape(4, 3))

print("5. reshape한 배열을 flatten() 함수를 사용하여 1차원 배열로 만들기:\n", arr.flatten())

# --------------------------------------------------------------

print('Q3) 1부터 100까지의 수로 구성된 배열에서 3의 배수이면서 5의 배수가 아닌 값만 추출하시오.')
# 그런 값들을 모두 제곱한 배열을 만들고 출력하시오.
print("1. 1부터 100까지의 수로 구성된 배열을 생성")
arr = np.random.randint(1, 100, 100)
print("arr:\n", arr)
print(" 3의 배수이면서 5의 배수가 아닌 값만 추출")
new_arr = [] # 얘는 파이썬 기본 리스트
for i in range(len(arr)):
    if (arr[i] % 3) == 0 and (arr[i] % 5) != 0:
        new_arr.append(arr[i])
print("new_arr: \n", *new_arr) # arr은 넘파이 배열이므로, *를 붙여야 타입을 빼고 출력함
print('넘파이 extract 함수 사용:\n', np.extract((arr % 3 == 0) & (arr % 5 != 0), arr))

# --------------------------------------------------------------

print('Q4) 다음과 같은 배열이 있다고 할 때,')
# arr = np.array([15, 22, 8, 19, 31, 4])
# 값이 10 이상이면 'High', 그렇지 않으면 'Low'라는 문자열 배열로 변환하시오.
# 값이 20 이상인 요소만 -1로 바꾼 새로운 배열을 만들어 출력하시오. (원본은 유지)
# 힌트: np.where(), np.copy()

print("1. 배열을 생성")
arr = np.array([15, 22, 8, 19, 31, 4])
print("arr:\n", arr)

print("2. 값이 10 이상이면 'High', 그렇지 않으면 'Low'라는 문자열 배열로 변환")
print(np.where(arr >= 10, 'High', 'Low'))

print("3. 값이 20 이상인 요소만 -1로 바꾼 새로운 배열을 만들어 출력 (원본 유지)")
new_arr = np.where(arr > 20, -1, arr)
print("기존 데이터 변경되는지 확인용 arr:\n", arr) # 기존 데이터 변경하는지 확인용
print("new_arr:\n", new_arr)

# --------------------------------------------------------------

print('Q5) 정규분포(평균 50, 표준편차 10)를 따르는 난수 1000개를 만들고, 상위 5% 값만 출력하세요.')
# 힌트 :  np.random.normal(), np.percentile()
print("1.  정규분포(평균 50, 표준편차 10)를 따르는 난수 1000개 생성")
arr = np.random.normal(50, 10, 1000)
print("arr:\n", arr)

print("2.  상위 5% 값만 출력")
print("상위 5% 기준 값", np.percentile(arr, 95))
print('넘파이 extract 함수 사용:\n', np.extract((arr > np.percentile(arr, 95)), arr))