# 알고리즘: 문제 해결을 위한 단계적 절차
# 컴퓨터가 이해할 수 있도록 명확하게 작성해야 함
# 모델은 상용 또는 오픈소스 사용 가능
# 실무 개발을 위해 알고리즘 이해와 구현 능력 필요
# 학력과 실력 모두 중요, 알고리즘

# 알고리즘이 필요한 분야 예시:
# - 정렬(Sorting): 버블 정렬, 퀵 정렬, 병합 정렬 등
# - 탐색(Search): 이진 탐색, 선형 탐색 등
# - 암호화(Encryption): AES, RSA, 해시 함수 등
# - 경로 탐색(Path Finding): 다익스트라, A* 알고리즘 등
# - 데이터 압축(Compression): 허프만 코딩, LZW 등
# - 최적화(Optimization): 유전 알고리즘, 동적 계획법 등
# - 머신러닝(Machine Learning): 의사결정트리, 신경망 등
# - 네트워크 라우팅(Network Routing): 벨만-포드, OSPF 등

# 전통적인 방식의 프로그래밍 절차: 문제 -> 입력 -> 알고리즘으로 처리 -> 출력

# 알고리즘 분석: 어떤 방식이 더 효과적인가?
# - 1) 시간 복잡도: 알고리즘이 입력 크기(n)에 따라 실행되는 시간의 증가 정도.
#   예시) 버블 정렬은 두 중첩 반복문을 사용하므로 O(n^2)번 비교가 필요함.
# - 2) 공간 복잡도: 알고리즘이 입력 크기(n)에 따라 추가로 필요한 메모리 양.
#   예시) 병합 정렬은 정렬을 위해 입력 크기만큼의 임시 배열이 필요하므로 O(n)의 공간이 필요함.
# - 3) Big O 표기법: 입력이 커질 때(최악의 경우) 시간 또는 공간 복잡도의 상한을 수학적으로 표기.
#   예시) 이진 탐색은 배열을 반씩 나누며 탐색하므로 O(log n)의 시간 복잡도를 가짐.

# ------------------------------------------------------------------------------------------------
import time

#문1) 1 ~ 10(n)까지의 정수의 합 구하기
def totFunc(n):
    total=0                    # 시간 복잡도: O(1) -> 횟수가 늘어날 수록 영향 없음
    for i in range(1, n+1):    
        total += i             # 시간 복잡도: O(1) * n번 = O(n) -> 횟수가 늘어나도 영향 있음
    return total               # 시간 복잡도: O(1) -> 횟수가 늘어날 수록 영향 없음
# 시간 복잡도 분석: 입력 크기가 커질 때, 연산 횟수가 어떻게 증가하는가?
# - 입력 크기 n에 따라 반복문이 n번 반복
# - n × O(1) = O(n)
# - 최종 시간 복잡도: O(n)

# 공간 복잡도 분석: 입력 크기가 커질 때, 추가로 필요한 메모리 양은?
# - 메모리는 total 하나만 씀 / 공간 복잡도: O(1): 입력 크기가 커져도 메모리 사용량은 일정

def fastFunc(n):
    return n * (n + 1) // 2  # 시간 복잡도: O(1) -> 횟수가 늘어날 수록 영향 없음
# 시간 복잡도 분석: 입력 크기가 커질 때, 연산 횟수가 어떻게 증가하는가?
# - 반복문이 입력 크기 n에 관계없이 1바퀴
# - 최종 시간 복잡도:O(1)

# 공간 복잡도 분석: 입력 크기가 커질 때, 추가로 필요한 메모리 양은?
# - 메모리는 n, n+1, 2를 사용 / 공간 복잡도: O(1): 입력 크기가 커져도 메모리 사용량은 일정

# n 값	        totFunc 연산 횟수	     fastFunc 연산 횟수
# n=10	        10번 덧셈	            3번 연산 (곱셈+덧셈+나눗셈)
# n=100	        100번 덧셈	            3번 연산
# n=1000	    1000번 덧셈	            3번 연산
# n=1000000	    1000000번 덧셈	        3번 연산


# n=1000000일 때
start = time.time()
result1 = totFunc(100)  # 약 0.1초
end = time.time()
print("totFunc 실행 시간:", end - start)

start = time.time()
result2 = fastFunc(100)  # 약 0.000001초
end = time.time()
print("fastFunc 실행 시간:", end - start)

# ------------------------------------------------------------------------------------------------
# 주요 알고리즘별 시간 복잡도 (Big O 표기법)

# 1. 스택 연산
# - PUSH: O(1) - 스택 맨 위에 원소 추가
# - POP: O(1) - 스택 맨 위 원소 제거

# 2. 탐색 알고리즘
# - 이진트리 탐색: O(log n) - 균형잡힌 트리일 때, 최악의 경우 O(n)
# - FOR문 (선형 탐색): O(n) - 모든 원소를 하나씩 확인

# 3. 정렬 알고리즘
# - 퀵 정렬: 평균 O(n log n), 최악 O(n²) - 피벗 선택에 따라 달라짐
# - 병합 정렬: O(n log n) - 항상 일정한 성능 보장
# - 힙 정렬: O(n log n) - 힙 구조를 이용한 정렬
# - 삽입 정렬: O(n²) - 이미 정렬된 경우 O(n)
# - 버블 정렬: O(n²) - 인접한 원소끼리 비교하여 정렬
# - 선택 정렬: O(n²) - 최솟값을 찾아 앞으로 이동

# 4. 반복문
# - 단일 FOR문: O(n) - n번 반복
# - 이중 FOR문: O(n²) - n × n번 반복

# 5. 수열
# - 피보나치 수열 (재귀): O(2ⁿ) - 지수적 증가로 매우 비효율적
# - 피보나치 수열 (동적계획법): O(n) - 이전 계산 결과를 저장하여 효율화

# 성능 순서 (빠른 순): O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ)
# ------------------------------------------------------------------------------------------------

#문2) 임의 정수들 중 최대값 찾기
# 입력: 숫자 n개를 가진 리스트
# 최대값 찾기
# 출력: 숫자 n개 중 최대값

def findMax_Func1(a):
    n = len(a) # 리스트의 길이
    max_v = a[0]
    for i in range(1, n):
        if a[i] > max_v:
            max_v = a[i] # 최대값 변경
    return max_v

d = [17, 92, 11, 33, 55, 7, 27, 42]
print("최대값1:", findMax_Func1(d))

def findMax_Func2(a):
    n = len(a) # 리스트의 길이
    max_v = 0  # ✅ 수정: 인덱스로 초기화 (값이 아닌 인덱스)
    for i in range(1, n):
        if a[i] > a[max_v]:  # 올바른 비교
            max_v = i # 최대값의 인덱스 저장
    return a[max_v]

print("최대값2:", findMax_Func2(d))

#문3) 동명이인 찾기: n명의 사람 이름 중 동일한 이름을 찾아 결과를 출력
temp = ['길동', '순신', '순신', '길동']
print("동명이인 찾기 전:", temp)
temp2 = set(temp) # 중복 제거
temp = list(temp2) # 다시 리스트로 변환
print("동명이인 제거 후:", temp)

# 알고리즘 구상
def findSameFunc(a):
    result = set()  # 중복된 이름을 저장할 집합
    for i in range(0, len(a)-1): # 0부터 n-2까지 반복
        for j in range(i + 1, len(a)):
            if a[i] == a[j]:
                result.add(a[i])  # 중복된 이름 추가
    return result

names = ['tom', 'jerry', 'mike', 'tom']
print("동명이인 찾기 전:", names)
print("동명이인 제거 후:", findSameFunc(names))  # 중복 제거

#문4) 팩토리얼 구하기
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n-1)

print("팩토리얼 구하기1: ", factorial(5))  # 예시: 5! = 120

def factorial2(n):
    if n <= 1:
        return 1
    return n * factorial2(n - 1)

print("팩토리얼 구하기2: ", factorial2(5))  # 예시: 5! = 120

# 재귀 연습1) 1부터 N까지의 합 구하기: 재귀 사용
def sum_recursive(n):
    if n <= 1:
        return 1
    return n + sum_recursive(n-1)

print("재귀 합 테스트: ", sum_recursive(10))

# 재귀 연습2) 숫자 N개 중에서 최대값 찾기: 재귀 사용
def max_recursive(a):
    n = len(a)
    max_value = a[0]
    if n >= 1:

        n =- 1

    return a[0]